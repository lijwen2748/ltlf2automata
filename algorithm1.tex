\section{Implementation}\label{sec:algorithm}
Given an $LTL_f$ formula $\phi$, there is a \NFA $A_{\phi}$ which accepts exactly the same language as $\phi$. To construct the nondeterministic finite automaton (\NFA) for an $ LTL_f$ formula $\phi$, our approach first constructs the corresponding transition-based \NFA, then converts the \TNFA to its equivalent \NFA. The following two subsections will describe this process. The first subsection describes the algorithm of \ltlf-to-\TNFA. The second subsection describes the algorithm of \TNFA-to-\NFA.

\subsection{\ltlf-to-\TNFA}
Given an  $ LTL_f$ formula, we define the construction of the \TNFA  as follows: \\
  \begin{algorithm}[H]
    \SetAlgoNoLine
 \SetKwInOut{Input}{\textbf{Input}}\SetKwInOut{Output}{\textbf{Output}}
 \Input{ An $ LTL_f$ formula $\phi$\\}
    \Output{ \TNFA $A^{tn}$\\}
    \BlankLine
 $to\_process:= \{\phi\}$\\
 S = $\{\phi\}$ \\
\textbf{while} $to\_process$ is not empty \textbf{do} \\
\ cur =  $to\_process$.front;  \\
\quad  \textbf{while} true \textbf{do} \\
\qquad   \textbf{if} cur is not satisfiable  \textbf{then} \{ \\
\qquad \quad $to\_process$.pop; \\
\qquad \quad break;     \}\\
 \qquad  next = $\rho(cur, cur.label)$ \\
\qquad\textbf{if} next is not in existing \textbf{then} \{ \\
\qquad \quad $to\_process$.push($next$); \\
\qquad \quad existing.push($next$); \\
\qquad  \quad add a new state $next$ in S\\
\qquad  add a new transition $cur\tran{label}next$
 \caption{Construction of the \TNFA}
\end{algorithm}
~\\
The algorithm constructs the automaton on-the-fly. S is the set of states in \TNFA $A^{tn}$. The initial state is set to be $\{\phi\}$, which is the input formula in the \XNF. $to\_process$ is used to store a collection of states to be processed. Visited states are stored in $existing$. $front$ is used to describe the first element of an array. In a transition $s_1\tran{\omega}s_2$, $\omega$ is the $label$, $s_2$ is the $next$ state. 


In this algorithm, we first use \SAT solvers to check if $\phi$ is satisfiable. If the answer is true, proceed to the next step, and if the answer is false, stop. After that, we leverage $\SAT solvers$ to get a transition $cur\tran{label}next$, and then we check if the state $next$ has been processed. If the answer is true, then we add the transition to ${A_{\phi}}^{tn}$, otherwise, the state $next$ will be added to  $to\_process$,existing and ${A_{\phi}}^{tn}$ respectively. 


The algorithm above mentions the construction of the \TNFA, but does not mention the determination of accepting conditions. By the way, the accepting condition in \TNFA is that if there is such a transition $s_1\tran{w}s_2$, where $w\models s_1$, then the transition is accepting.  


\subsection{\TNFA-to-\NFA}  
In the previous section, we constructed the state and transition of the \TNFA. This section will focus on the conversion from \TNFA-to-\NFA, with the addition of accepting states. The algorithm is stated as follows:\\

\IncMargin{1em}
 \begin{algorithm}[H]
    \SetAlgoNoLine
 \SetKwInOut{Input}{\textbf{Input}}\SetKwInOut{Output}{\textbf{Output}}
 \Input{ \TNFA $A^{tn}$\\}
    \Output{  \NFA $A^{n}$}
    \BlankLine
$S' = S\cup \{f\}$\\
\textbf{for} state s in $S'$ \\
\qquad  $ \textbf{for}$ w in s.label\_set  \\
\qquad  \quad \textbf{if} $w \models s$   \textbf{then}\{      \\
\qquad \qquad add a new transition $s\tran{w}f$;    \}     \\
 \caption{\TNFA-to-\NFA}
\end{algorithm}
~\\
The algorithm converts the \TNFA to \NFA by a few modifications to the original automaton. S is used to represent the set of states in \TNFA. While $S'$ is used to represent the set of states in \NFA, with the addition of a new state f compared to S. Unlike \TNFA, the accepting condition of \NFA is defined over states. Thus, the algorithm use f to denote the accepting state. $label\_set$ is used to represent the set of s.labels. 

In this algorithm, our approach adds a new transition $s\tran{w}f$ in the automaton for every accepting transition $s\tran{w}s'$ in the \TNFA. 
